// nexus_core/src/matching/orderbook.rs
//
// The Institutional-Grade Order Book.
//
// DATA STRUCTURE CHOICE: BTreeMap<i64, VecDeque<Order>>
//
// WHY BTreeMap (NOT HashMap):
//   - BTreeMap keeps keys sorted. This means `best_bid()` and `best_ask()` are
//     O(log N) via `.iter().next_back()` / `.iter().next()`.
//   - For price discovery (finding the best opposing price to match against),
//     sorted order is MANDATORY. HashMap would require scanning all keys: O(N).
//   - BTreeMap nodes are contiguous arrays (B-tree nodes hold ~11 keys each),
//     giving significantly better cache locality than a Red-Black tree.
//
// WHY VecDeque (NOT Vec or LinkedList):
//   - At each price level, orders are matched FIFO (First-In, First-Out).
//   - VecDeque provides O(1) push_back (new order arrives) and O(1) pop_front
//     (oldest order gets matched). Vec's pop_front is O(N) due to shifting.
//   - VecDeque uses a contiguous ring buffer internally, so iterating through
//     orders at a price level is cache-friendly (no pointer chasing like LinkedList).
//
// LATENCY ANALYSIS:
//   BTreeMap lookup:     O(log N) where N = number of distinct price levels.
//                        At 1000 active price levels, log₂(1000) ≈ 10 comparisons.
//                        Each comparison is an i64 compare (~1ns). Total: ~10ns.
//   VecDeque pop_front:  O(1). ~2ns.
//   Total per match:     ~12ns for price discovery + queue drain.
//   With 10 fills:       ~120ns.
//   Overhead (struct copies, trade generation): ~100-200ns.
//   TOTAL ESTIMATE:      ~300-500ns per order (well under the 2μs target).

use std::collections::{BTreeMap, VecDeque};

/// A resting order on the book. Compact, cache-aligned.
///
/// Size: 32 bytes. Two orders fit in a single 64-byte cache line.
#[derive(Debug, Clone)]
pub struct Order {
    pub trader_id: u32,
    pub order_id: u64,
    /// Fixed-point price (scaled by 10^8).
    pub price: i64,
    /// Remaining quantity.
    pub qty: u32,
    /// Timestamp in nanoseconds (for time priority tiebreaking).
    pub ts: u64,
}

/// The result of a single fill between an aggressor and a resting maker order.
#[derive(Debug, Clone)]
pub struct Fill {
    pub maker_order_id: u64,
    pub taker_order_id: u64,
    pub maker_trader_id: u32,
    pub taker_trader_id: u32,
    /// Fixed-point execution price.
    pub price: i64,
    pub qty: u32,
    pub timestamp_ns: u64,
}

/// Why an order was rejected before touching the book.
#[derive(Debug, Clone, PartialEq)]
pub enum RejectReason {
    /// Price deviates more than the configured percentage from last trade.
    FatFinger { order_price: i64, reference_price: i64 },
    /// Quantity exceeds the hard maximum.
    MaxQuantity { requested: u32, max: u32 },
    /// Price must be > 0 for limit orders.
    InvalidPrice,
    /// Quantity must be > 0.
    InvalidQuantity,
}

/// The outcome of submitting an order to the engine.
#[derive(Debug)]
pub struct MatchResult {
    /// The exchange-assigned order ID.
    pub order_id: u64,
    /// Fills generated by the aggressor crossing the book.
    pub fills: Vec<Fill>,
    /// Order IDs cancelled due to Self-Trade Prevention.
    pub stp_cancels: Vec<u64>,
    /// Remaining quantity that was posted to the book (0 if fully filled).
    pub resting_qty: u32,
}

/// Configuration for the risk guardian embedded in the engine.
#[derive(Debug, Clone)]
pub struct RiskConfig {
    /// Maximum allowed deviation from last trade price, as a fixed-point percentage.
    /// e.g., 10_000_000 = 10% (in 10^8 scale, 0.10 * 10^8).
    pub max_price_deviation_pct: i64,
    /// Hard maximum order quantity.
    pub max_order_qty: u32,
}

impl Default for RiskConfig {
    fn default() -> Self {
        Self {
            // 10% deviation allowed by default.
            max_price_deviation_pct: 10_000_000, // 0.10 * 10^8
            max_order_qty: 1_000_000,
        }
    }
}

/// One side of the limit order book.
///
/// Bids: highest price = best (we iterate from the back of BTreeMap).
/// Asks: lowest price = best (we iterate from the front of BTreeMap).
#[derive(Debug, Default)]
pub struct BookSide {
    /// Price levels mapped to FIFO queues of resting orders.
    pub levels: BTreeMap<i64, VecDeque<Order>>,
    /// Total resting quantity across all levels (for fast snapshot).
    pub total_qty: u64,
}

impl BookSide {
    /// Insert a resting order at the given price level. O(log N) for new level, O(1) amortized for existing.
    pub fn insert(&mut self, order: Order) {
        self.total_qty += order.qty as u64;
        self.levels
            .entry(order.price)
            .or_insert_with(VecDeque::new)
            .push_back(order);
    }

    /// Remove a specific order by ID (for cancels). O(N) in worst case but cancels are off the hot path.
    pub fn cancel_order(&mut self, order_id: u64) -> Option<Order> {
        for (_price, level) in self.levels.iter_mut() {
            if let Some(pos) = level.iter().position(|o| o.order_id == order_id) {
                let order = level.remove(pos).unwrap();
                self.total_qty -= order.qty as u64;
                return Some(order);
            }
        }
        None
    }

    /// Remove empty price levels to keep the BTreeMap clean.
    pub fn prune_empty_levels(&mut self) {
        self.levels.retain(|_price, level| !level.is_empty());
    }

    /// Number of distinct price levels.
    pub fn num_levels(&self) -> usize {
        self.levels.len()
    }

    /// Check if the book side is empty.
    pub fn is_empty(&self) -> bool {
        self.levels.is_empty()
    }
}

/// A price level in an L2 (Market-By-Price) snapshot.
#[derive(Debug, Clone)]
pub struct L2Level {
    /// Fixed-point price.
    pub price: i64,
    /// Total quantity at this price.
    pub qty: u64,
    /// Number of orders at this price.
    pub order_count: u32,
}

/// The full order book: Bids + Asks + sequence tracking.
#[derive(Debug, Default)]
pub struct OrderBook {
    pub bids: BookSide,
    pub asks: BookSide,
    next_order_id: u64,
    /// Last traded price for Fat-Finger reference. None if no trades yet.
    pub last_trade_price: Option<i64>,
}

impl OrderBook {
    pub fn new() -> Self {
        Self::default()
    }

    /// Allocate the next unique order ID. Monotonically increasing. O(1).
    pub fn next_order_id(&mut self) -> u64 {
        self.next_order_id += 1;
        self.next_order_id
    }

    /// Best bid price (highest). O(log N).
    pub fn best_bid(&self) -> Option<i64> {
        self.bids.levels.keys().next_back().copied()
    }

    /// Best ask price (lowest). O(log N).
    pub fn best_ask(&self) -> Option<i64> {
        self.asks.levels.keys().next().copied()
    }

    /// Midpoint price for mark calculations. Integer division (truncates).
    pub fn midpoint(&self) -> Option<i64> {
        match (self.best_bid(), self.best_ask()) {
            (Some(bid), Some(ask)) => Some((bid + ask) / 2),
            (Some(bid), None) => Some(bid),
            (None, Some(ask)) => Some(ask),
            (None, None) => None,
        }
    }

    /// Generate an L2 snapshot of the top `depth` price levels on each side.
    pub fn l2_snapshot(&self, depth: usize) -> (Vec<L2Level>, Vec<L2Level>) {
        let bid_levels: Vec<L2Level> = self.bids.levels.iter().rev().take(depth).map(|(&price, level)| {
            L2Level {
                price,
                qty: level.iter().map(|o| o.qty as u64).sum(),
                order_count: level.len() as u32,
            }
        }).collect();

        let ask_levels: Vec<L2Level> = self.asks.levels.iter().take(depth).map(|(&price, level)| {
            L2Level {
                price,
                qty: level.iter().map(|o| o.qty as u64).sum(),
                order_count: level.len() as u32,
            }
        }).collect();

        (bid_levels, ask_levels)
    }

    /// Clear the entire book (session reset).
    pub fn clear(&mut self) {
        self.bids.levels.clear();
        self.bids.total_qty = 0;
        self.asks.levels.clear();
        self.asks.total_qty = 0;
    }

    /// Cancel all orders for a specific trader (Cancel-on-Disconnect).
    pub fn cancel_all_for_trader(&mut self, trader_id: u32) -> Vec<u64> {
        let mut cancelled_ids = Vec::new();

        for (_price, level) in self.bids.levels.iter_mut() {
            level.retain(|o| {
                if o.trader_id == trader_id {
                    cancelled_ids.push(o.order_id);
                    false
                } else {
                    true
                }
            });
        }
        for (_price, level) in self.asks.levels.iter_mut() {
            level.retain(|o| {
                if o.trader_id == trader_id {
                    cancelled_ids.push(o.order_id);
                    false
                } else {
                    true
                }
            });
        }
        self.bids.prune_empty_levels();
        self.asks.prune_empty_levels();

        // Recalculate totals after bulk cancel.
        self.bids.total_qty = self.bids.levels.values()
            .flat_map(|level| level.iter())
            .map(|o| o.qty as u64)
            .sum();
        self.asks.total_qty = self.asks.levels.values()
            .flat_map(|level| level.iter())
            .map(|o| o.qty as u64)
            .sum();

        cancelled_ids
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_order_struct_size() {
        // Order must be compact. 32 bytes = half a cache line.
        assert!(std::mem::size_of::<Order>() <= 40, "Order is too large for cache efficiency");
    }

    #[test]
    fn test_book_side_insert_and_best() {
        let mut book = OrderBook::new();
        book.bids.insert(Order {
            trader_id: 1, order_id: 1, price: 100_00000000, qty: 10, ts: 1,
        });
        book.bids.insert(Order {
            trader_id: 2, order_id: 2, price: 101_00000000, qty: 20, ts: 2,
        });
        book.asks.insert(Order {
            trader_id: 3, order_id: 3, price: 102_00000000, qty: 15, ts: 3,
        });

        assert_eq!(book.best_bid(), Some(101_00000000));
        assert_eq!(book.best_ask(), Some(102_00000000));
    }

    #[test]
    fn test_l2_snapshot() {
        let mut book = OrderBook::new();
        // Add 3 bid levels.
        for i in 0..3 {
            book.bids.insert(Order {
                trader_id: 1,
                order_id: i + 1,
                price: (100 + i as i64) * 100_000_000,
                qty: (10 + i) as u32,
                ts: i as u64,
            });
        }
        let (bids, asks) = book.l2_snapshot(5);
        assert_eq!(bids.len(), 3);
        assert_eq!(asks.len(), 0);
        // Best bid (highest price) should be first.
        assert_eq!(bids[0].price, 102_00000000);
    }

    #[test]
    fn test_cancel_all_for_trader() {
        let mut book = OrderBook::new();
        book.bids.insert(Order { trader_id: 1, order_id: 1, price: 100_00000000, qty: 10, ts: 1 });
        book.bids.insert(Order { trader_id: 2, order_id: 2, price: 100_00000000, qty: 20, ts: 2 });
        book.asks.insert(Order { trader_id: 1, order_id: 3, price: 105_00000000, qty: 5, ts: 3 });

        let cancelled = book.cancel_all_for_trader(1);
        assert_eq!(cancelled.len(), 2); // order 1 and order 3
        assert_eq!(book.bids.levels[&100_00000000].len(), 1); // only trader 2 remains
        assert!(book.asks.is_empty());
    }
}
